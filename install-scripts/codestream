#!/bin/bash

[ "$1" == "--funcs" ] && grep '^# ' $0 && exit 0  # for development

# 
# usage()
#   desc: print command line usage & option descriptions
function usage {
	local cmd=`basename $0`
	echo "
Usage:

  The CodeStream On-Prem Administration Guide is here:

    https//docs.codestream.com/onprem/

  QuickStart
    $cmd --quickstart [--topology { hostname | ip }] \\
                            [--public-host <hostname-or-ip>] \\
                            [--api-port <port>] [--bcast-port <port>] [--admin-port <port>] \\
                            [--mongo-url <url>]

  Container Control
    $cmd { --start | --stop | --restart | --reset | --status } [--not-mongo]
    $cmd --start-mongo                                      # start the mongo container only

  Updates & Backups
    $cmd --update-myself                                    # update the codestream control script and utilities
    $cmd --update-containers [--no-start] [--no-backup]     # grab latest container versions (performs backup)
    $cmd --backup                                           # backup mongo database
    $cmd --restore { latest | <file> }                      # restore mongo database from latest backup or <file>
    $cmd --full-backup                                      # backup mongo and the entire configuration directory

  Maintenance and Support
    $cmd --logs { Nh | Nm }                                 # collect last N hours or minutes of logs
    $cmd --logtail [N]                                      # quick tail of all service logs (N lines)
    $cmd --apply-support-pkg <support-pkg>                  # apply the codestream-provided support package
    $cmd --create-mst-app-pkg <app-id> <public-api-host>    # create a custom MST App Package
    $cmd --repair-db <repair-script.js>                     # run mongo repair commands
    $cmd --run-api-utility <script>                         # run an api utility in the API container
    $cmd --run-support-script <script>                      # run a support script located in $CS_ROOT/support/
    $cmd --undo-stack                                       # print the undo stack
    $cmd --run-python-script <script> <opts>                # run a python script using the codestream python container
    $cmd --make-self-signed-cert <hostName>                 # create a key and self-signed SSL certificate (requires openssl)
    $cmd --api-shell                                        # shell prompt in api container
    $cmd --cfg-tool [options]                               # run mongo config loader tool

        >>>  mongo data _should_ persist following a mongo container reset, but  <<<
        >>>  make sure you back up the data with '--backup' beforehand.          <<<

    Note: touch 'mongo.off' if you're providing your own mongo db and don't want
    to run the mongodb docker container included here.
"
	exit 1
}

# 
# ###########################################################
# # Local development
# ###########################################################

# 
# reset_dev_env()
#   desc: Reset the installation by removing installation files, conatiners &
#         volumes and optionally images and container-versions file.
function reset_dev_env {
	yesno "This will remove all CS containers and ALL docker volumes. Are you sure (y/N)? " no && echo "aborted" && return 1
	cd $CS_ROOT || exit 1
	./codestream --reset
	[ `docker volume ls | wc -l` -gt 1 ] &&	docker volume rm $(docker volume ls | awk '{print $2}' | grep -v VOL)
	/bin/rm -f terms.txt mongo.url .status-urls .tos-agreed product-type container-versions compose.yaml compose.yaml.template
	[ -L ./util ] && /bin/rm ./util
	[ -d ./util ] && /bin/rm -rf ./util
	yesno "Remove all images (y/N)? " no || docker rmi $(docker images|awk '{print $3}'|grep -v IMA)
	return 0
}


# 
# ###########################################################
# # Core utilities
# ###########################################################

# 
# yesno(prompt)
#   desc: prompt for a yes or no answer to a question
#   args:
#         prompt       message to display
#         defautlVal   "yes" or "no" (optional. default will force an answer)
#   returns:
#         0   no
#         1   yes
function yesno {
	local prompt=$1
	local defVal=$2
	local ans
	echo -n "$prompt"
	read ans
	[ -z "$ans" -a -n "$defVal" ] && { [ $defVal == y ] && return 1 || return 0; }
	while [ "$ans" != "y" -a "$ans" != "n" ]; do
		echo -n "y or n ? "
		read ans
	done
	[ $ans == "y" ] && return 1
	return 0
}

# 
# random_string(strLen)
#   desc: generate a random string of characters of specified length (relies on
#         /dev/urandom)
#   args:
#         strLen    (int) length of the random character string
#   returns:
#         none. prints to stdout
function random_string {
	local strLen=$1
	[ ! -c /dev/urandom ] && echo "the /dev/urandom device was not found - cannot generate a random string" && exit 1
	[ -z "$strLen" ] && strLen=18
	head /dev/urandom | $TR_CMD -dc A-Za-z0-9 | head -c $strLen ; echo ''
}

# 
# check_env()
#   desc: check for existence of required system commands
#   returns:
#         0   all commands found
#         1   missing commands - should not proceed
function check_env {
	local rc=0
	local cmd
	[ -z "$HOME" ] && echo "\$HOME is not defined" >&2 && rc=1
	for cmd in docker curl $TR_CMD touch
	do
		[ -z `which $cmd 2>/dev/null` ] && echo "'$cmd' command not found in search path" >&2 && rc=1
	done
	return $rc
}

# 
# get_uuid()
#   desc: generate a UUID using a local utility (uuidgen > uuid) or via
#         an http call to www.uuidtools.com.
#   returns:
#       none. print UUID on stdout
function get_uuid {
	local uuid
	[ -z "$CS_INSTALL_FROM_PKG" ] && [ -f $CS_ROOT/.UUID ] && cat $CS_ROOT/.UUID && return
	which uuidgen >/dev/null 2>&1 && { uuidgen -t && return || exit 1; }
	which uuid >/dev/null 2>&1 && { uuid && return || exit 1; }
	# curl -s https://www.uuidtools.com/api/decode/9084b876-4209-4e84-91d4-a7221c63ad65 | python3 -m json.tool
	curl -s https://www.uuidtools.com/api/generate/timestamp-first|cut -f2 -d'"' || exit 1
	return
}

# 
# guess_primary_ip()
#   desc: guess the primary ip address of this host.
#   returns:
#         none. IP address is printed to stdout
function guess_primary_ip {
	# AWS ec2 insetances
	which ec2-metadata >/dev/null 2>&1 && ec2-metadata --local-ipv4 | awk '{print $2}' && return
	# proc fs
	if [ -f /proc/net/route ]; then
		local default_iface=$(awk '$2 == 00000000 { print $1 }' /proc/net/route)
		local x = `ip addr show dev "$default_iface" | awk '$1 == "inet" { sub("/.*", "", $2); print $2 }'`
		[ -n "$x" ] && echo $x && return
	fi
	# last resource - this isn't a good idea because hostname's output is unordered
	[ "$CS_PRODUCT_TYPE" == "Single Linux Host" ] && hostname -I | awk '{print $1}' && return
	[ "$CS_PRODUCT_TYPE" == "Single Mac Host" ] && ipconfig getifaddr $(route -n get default|grep interface|awk '{print $2}')
	return
}

# 
# system_type()
#   desc: determine if system is Mac or Linux
#   returns:
#         none. prints 'Mac' or 'Linux' to stdout. exits if undetermined.
function system_type {
	[ `uname -s` == Darwin ] && echo Mac && return 0
	[ `uname -s` == Linux ] && echo Linux && return 0
	echo "FATAL: Cannot determine this system type using 'uname -s'" >&2
	exit 1
}

# 
# expand_template(template output [variable-list])
#   desc: simple expansion of a template file using {{ varName }} notation.
#         provides for CS_, CSSVC_ & known docker repo name and image version
#         variables.
#   returns:
#         none. creates output file (expanded templte) if successful. exits otherwise.
function expand_template {
	local template=$1 output=$2
	shift 2
	local varName varVal tmpFile=/tmp/tfile.$$
	local otherVars="mongoDockerVersion rabbitmqRepo rabbitDockerVersion apiRepo apiDockerVersion apiServerPort broadcasterRepo broadcasterDockerVersion broadcasterPort mailoutRepo mailoutDockerVersion opadmRepo opadmDockerVersion adminServerPort"
	/bin/cp $template $tmpFile || exit 1
	for varName in $(env | egrep -e '^(CS|CSSVC)_' | cut -f1 -d=) $otherVars "$@"
	do
		grep -q "{{ $varName }}" $tmpFile || continue
		varVal=`eval "echo \\$$varName"`
		# echo "varName=$varName, varVal=$varVal"
		cat $tmpFile | sed -e "s|{{ $varName }}|$varVal|g" >$tmpFile.2 || exit 1
		/bin/mv -f $tmpFile.2 $tmpFile || exit 1
	done
	/bin/mv -f $tmpFile $output || exit 1
}

# 
# ###########################################################
# # Updates
# ###########################################################

# 
# update_myself()
#   desc: download the latest version of this script in place (then immediately exit)
#   returns:
#         none. exists upon completion
function update_myself {
	[ -L $0 ] && echo "this script is a sym link. Update aborted" && exit 1
	if [ -z "$CS_INSTALL_FROM_PKG" ]; then
		# fetch_utilities --force
		(
			curl https://raw.githubusercontent.com/TeamCodeStream/onprem-install/$CS_INSTALLATION_BRANCH/install-scripts/codestream -o $CS_ROOT/codestream -s
			chmod +x $CS_ROOT/codestream
		)
		# this is special - WE GO NO FURTHER AFTER UPDATING OURSELF BECAUSE THE BASH INTERPRETER IS LIKELY TO BARF
	else
		echo "Running from a package update. --update_myself does not apply"
	fi
	exit 0
}

# 
# fetch_a_file_as(srcFile targetFile [undoStackId])
#   desc: fetch a file from githubusercontent or local copy of repo (air-gapped) while
#         accounting for installation branch and release. Uses undo stack. In this
#         routine, the file naming convention adds the release as an extension to
#         the source file name.
#   args:
#       srcFile               relative path from root of repo (eg. versions/preview-single-host.ver)
#       targetFile            target file name (will be located in $CS_ROOT)
#       undoId (optional)     for storing existing file(s) in the undo stack
#   returns:
#        0   successfully updated
#        1   no update necessary
#        2   error during update
function fetch_a_file_as {
	local srcFile="$1" targetFile="$2" undoId="$3"
	if [ "$CS_RELEASE" == development ]; then
		# [ ! -L $targetFile ] && echo "File does not exist" || echo "File exists"
		# ls -l $targetFile
		# read
		[ ! -L $targetFile ] && ln -s $OPI_TOP/$srcFile.development $targetFile
		return 0
	elif [ -z "$CS_INSTALL_FROM_PKG" ]; then
		local versionUrl="https://raw.githubusercontent.com/TeamCodeStream/onprem-install/$CS_INSTALLATION_BRANCH/$srcFile"
		curl -s --fail --output $CS_ROOT/$targetFile.new "$versionUrl$CS_RELEASE_SUFX"
		[ $? -ne 0 ] && echo "Failed to download container versions ($versionUrl$CS_RELEASE_SUFX)" && return 2
	else
		local versionUrlFile=".onprem-install/$srcFile"
		cp $CS_ROOT/$versionUrlFile$CS_RELEASE_SUFX $CS_ROOT/$targetFile.new
		[ $? -ne 0 ] && echo "failed: cp $CS_ROOT/$versionUrlFile$CS_RELEASE_SUFX $CS_ROOT/$targetFile.new" && return 2
	fi
	if [ ! -f $CS_ROOT/$targetFile ]; then
		/bin/mv $CS_ROOT/$targetFile.new $CS_ROOT/$targetFile || return 2
		return 0
	fi
	x=`diff $CS_ROOT/$targetFile.new $CS_ROOT/$targetFile|wc -l`
	[ $x -eq 0 ] && /bin/rm -f $CS_ROOT/$targetFile.new && return 1
	[ -z "$undoId" ] && undoId=$(undo_stack_id "" "called update container versions()")
	/bin/mv -f $CS_ROOT/$targetFile $CS_ROOT/.undo/$undoId/$targetFile || return 2
	/bin/mv -f $CS_ROOT/$targetFile.new $CS_ROOT/$targetFile || return 2
	return 0
}

# 
# fetch_a_file_from_dir_as(srcFile targetFile [undoStackId])
#   desc: similar to fetch_a_file_as but the source file is located in a directory
#         representing the release or none for GA
#   args:
#       srcFile               relative path from root of repo (eg. config-templates/compose.yaml)
#       targetFile            target file name (will be located in $CS_ROOT)
#       undoId (optional)     for storing existing file(s) in the undo stack
#   returns:
#        0   successfully updated
#        1   no update necessary
#        2   error during update
function fetch_a_file_from_dir_as {
	local srcFile="$1" targetFile="$2" undoId="$3"
	local srcFileName="`dirname $srcFile`$CS_RELEASE_PATH/`basename $srcFile`"
	if [ "$CS_RELEASE" == development ]; then
		# [ ! -L $targetFile ] && echo "File does not exist" || echo "File exists"
		# ls -l $targetFile
		# read
		[ ! -L $targetFile ] && ln -s $OPI_TOP/$srcFileName $targetFile
		return 0
	elif [ -z "$CS_INSTALL_FROM_PKG" ]; then
		local versionUrl="https://raw.githubusercontent.com/TeamCodeStream/onprem-install/$CS_INSTALLATION_BRANCH/$srcFileName"
		curl -s --fail --output $CS_ROOT/$targetFile.new "$versionUrl"
		[ $? -ne 0 ] && echo "Failed to download container versions ($versionUrl)" && return 2
	else
		local versionUrlFile=".onprem-install/$srcFileName"
		cp $CS_ROOT/$versionUrlFile $CS_ROOT/$targetFile.new
		[ $? -ne 0 ] && echo "failed: cp $CS_ROOT/$versionUrlFile $CS_ROOT/$targetFile.new" && return 2
	fi
	if [ ! -f $CS_ROOT/$targetFile ]; then
		/bin/mv $CS_ROOT/$targetFile.new $CS_ROOT/$targetFile || return 2
		return 0
	fi
	x=`diff $CS_ROOT/$targetFile.new $CS_ROOT/$targetFile|wc -l`
	[ $x -eq 0 ] && /bin/rm -f $CS_ROOT/$targetFile.new && return 1
	[ -z "$undoId" ] && undoId=$(undo_stack_id "" "called update container versions()")
	/bin/mv -f $CS_ROOT/$targetFile $CS_ROOT/.undo/$undoId/$targetFile || return 2
	/bin/mv -f $CS_ROOT/$targetFile.new $CS_ROOT/$targetFile || return 2
	return 0
}

# 
# update_container_versions([undoStackId])
#   desc: update the file containing the container versions for this codestream release
#   args:
#       undoId (optional)     for storing existing file(s) in the undo stack
#   returns:
#       0   successfully updated
#       1   no update necessary
#       2   error during update
function update_container_versions {
	local undoId="$1"
	fetch_a_file_as versions/preview-single-host.ver container-versions $undoId
}

# 
# update_compose_file([port-file] [undoStackId])
#   desc: download the compose template if need be and then expand it
#   args:
#         flags   port-file: load public ports from port file (.container-ports)
#   returns:
#         none. compose.yaml will be present or script exits
function update_compose_file {
	local flags="$1" undoId="$2"
	[ ! -f compose.yaml.template ] && { fetch_a_file_from_dir_as config-templates/compose.yaml compose.yaml.template $undoId || exit 1; }
	echo $flags | grep -q port-file && { eval `cat $CS_ROOT/.container-ports` || { echo "$CS_ROOT/.container-ports not found" && exit 1; } }
	[ ! -f compose.yaml ] && expand_template $CS_ROOT/compose.yaml.template $CS_ROOT/compose.yaml
}

# 
# load_container_versions([undoStackId])
#   desc: source in the container version file. This file contains the repo names
#         and versions of each docker image. Default repo names reference GA.
#   args:
#         undoId    optional undo stack Id
#   returns:
#         none. container data is loaded or script will exit
function load_container_versions {
	local undoId="$1"
	[ ! -f $CS_ROOT/container-versions ] && { update_container_versions "$undoId" "called load_container_versions()" || exit 1; }
	apiRepo=""
	broadcasterRepo=""
	mailoutRepo=""
	rabbitmqRepo=""
	pythonRepo=""
	opadmRepo=""
	. $CS_ROOT/container-versions || exit 1
	[ -z "$apiRepo" ] && apiRepo="teamcodestream/api-onprem"
	[ -z "$broadcasterRepo" ] && broadcasterRepo="teamcodestream/broadcaster-onprem"
	[ -z "$mailoutRepo" ] && mailoutRepo="teamcodestream/mailout-onprem"
	[ -z "$rabbitmqRepo" ] && rabbitmqRepo="teamcodestream/rabbitmq-onprem"
	[ -z "$pythonRepo" ] && pythonRepo="teamcodestream/dt-python3"
	[ $CS_USE_ADMIN -eq 1 ] && [ -z "$opadmRepo" ] && opadmRepo="teamcodestream/opadm-onprem"
}

# 
# update_containers_except_mongo()
#   desc: Execute the docker update procedure
#   returns:
#         0    success
#         >0   fail
function update_containers_except_mongo {
	local parm nostart nobackup force
	for parm in "$@"; do
		[ $parm == "--no-start" ] && nostart=1
		[ $parm == "--no-backup" ] && nobackup=1
		[ $parm == "--force" ] && force=1
		# [ $parm == "--package" ] && CS_INSTALL_FROM_PKG=yes
	done
	local undoId=$(undo_stack_id "" "full container update procedure")
	stop_containers not-mongo
	[ -z "$nobackup" ] && { backup_dot_codestream $undoId && backup_mongo $CS_MONGO_URL $undoId || exit 1; }
	remove_containers not-mongo
	update_container_versions $undoId
	local rc=$?
	[ $rc -eq 2 ] && echo "error updating containers">&2 && exit 1
	if [ $rc -eq 0  -o  -n "$force" ]; then
		load_container_versions $undoId
		[ -n "$CS_INSTALL_FROM_PKG" ] && load_docker_containers_from_package
		# update_config_file $undoId
	else
		echo "You are already running the latest container versions"
	fi
	[ -n "$nostart" ] && return 0
	start_containers
}


# 
# ###########################################################
# # Undo Stack
# ###########################################################

# 
# undo_stack_id([undoStackId] [eventDescription])
#   desc: generate an undo stack Id and creates its directory An undo stack
#         Id is a top leveel directory in $CS_ROOT/.undo/ where we keep
#         backups of all the files we will need to undo the current transaction.
#   args:
#         undoId      optional Id - if not provided one will be generated
#         eventDesc   brief description of this undo transaction
#   returns:
#         none. prints undoId on stdout
function undo_stack_id {
	local undoId="$1"
	local eventDesc="$2"
	[ -z "$eventDesc" ] && eventDesc="no description"
	if [ "$undoId" == latest ]; then
		undoId=`(cd $CS_ROOT/.undo && /bin/ls |tail -1)`
	elif [ -z "$undoId" ]; then
		undoId=`date '+%Y-%m-%d_%H-%M-%S'`
	fi
	[ ! -d $CS_ROOT/.undo/$undoId ] && mkdir -p $CS_ROOT/.undo/$undoId
	echo "$eventDesc" >$CS_ROOT/.undo/$undoId/description
	echo $undoId
}

# 
# print_undo_stack()
#   desc: print the undo stack
#   returns:
#         none
function print_undo_stack {
	[ ! -d $CS_ROOT/.undo ] && echo "the undo stack is empty" >&2 && return
	for u in `ls $CS_ROOT/.undo`; do
		echo "  $u   `cat $CS_ROOT/.undo/$u/description`"
	done
}

# 
# ###########################################################
# # MongoDB Utilities & Backups
# ###########################################################

# 
# backup_dot_codestream([undoStackId])
#   desc: backup the contents of the $CS_ROOT directory tree into the undo stack
#   returns
#         none
function backup_dot_codestream {
	local undoId="$1"
	[ -z "$undoId" ] && undoId=$(undo_stack_id "" "called backup_dot_codestream()")
	tar -C $CS_ROOT -czpf $CS_ROOT/.undo/$undoId/dot.codestream.tgz  --exclude='backups*' --exclude='.undo*' --exclude='log-capture*' .
}

# 
# backup_mongo(mongoUrl)
#   desc: backup the mongo database using a temp mongo container to run mongodump.
#         Backup is in zipped archive format and stored in the backups dir.
#   args:
#         mongoUrl     mongo endpoint
#   returns:
#         0  success
#         1  fail
function backup_mongo {
	local mongoUrl="$1"
	# local undoId="$2"
	[ ! -d $CS_ROOT/backups ] && mkdir $CS_ROOT/backups
	local filename="dump_$(date '+%Y-%m-%d_%H-%M-%S').gz"
	docker run --rm $(docker_network_args 27017) mongo:$mongoDockerVersion mongodump --uri $mongoUrl --archive --gzip | cat > $CS_ROOT/backups/$filename
	[ $? -ne 0 -o \( ! -s $CS_ROOT/backups/$filename \) ] && echo "backup failed" >&2 && return 1
	echo "Backed up to $CS_ROOT/backups/$filename"
	return 0
}

# 
# restore_mongo(mongoUrl [<file> | latest] [prompt?])
#   desc: restore data to mongo from a previously made backup.
#   args:
#         mongoUrl    mongo endpoint
#         file        file to restore or 'latest' for latest in the backup dir
#         prompt      (optional) 'no' to short-circuit interactive confirmation
#   returns:
#         0  success
#         1  fail
function restore_mongo {
	local mongoUrl=$1 file=$2 prompt=$3
	[ -z "$file" ] && echo "usage: $0 --restore { latest | /path/to/dumpfile }" >&2 && return 1
	[ ! -f "$file" ] && echo "$file not found" >&2 && return 1
	echo "Restoring data from $file"
	echo -e "
  ***  WARNING   WARNING   WARNING  ***

  This will overwrite the data currently in mongo and replace it with the
  data from the backup file. The data currently in mongo will be lost!!
"
	if [ "$prompt" != no ]; then
		yesno "Do you want to proceed (y/N)? "
		[ $? -eq 0 ] && echo "never mind" && return 1
	fi
	cat $file | docker run --rm -i $(docker_network_args 27017) mongo:$mongoDockerVersion mongorestore --uri $mongoUrl --archive --gzip --drop
	[ $? -ne 0 ] && echo "error restoring data!!" >&2 && return 1
	return 0
}

# 
# full_backup()
#   desc: run a mongo backup and then do a full tar of the $CS_ROOT directory
#   returns:
#         none
function full_backup {
	csRootBase=`basename $CS_ROOT`
	{ backup_mongo $CS_MONGO_URL && d=`/bin/ls -tr $CS_ROOT/backups|tail -1|cut -f1 -d.|sed -e 's/dump_//'` && cd $CS_ROOT/.. && tar -czpf ~/full-codestream-backup.$d.tgz $csRootBase && echo -e "\nFull backup is here:" && /bin/ls -l ~/full-codestream-backup.$d.tgz || exit 1; }
}

# 
# ###########################################################
# # Container Execution Utilities
# ###########################################################

# execute a utility script included within an API container
function run_script_via_api {
	local script_name=$1
	[ -z "$script_name" ] && "script name required" && return 1
	[ "$CS_PRODUCT_TYPE" != "Single Linux Host" ] && echo "utility only available for Single Linux Host installations" && return 1
	shift
	echo docker run --rm -v $CS_ROOT:/opt/config --network=host $apiRepo:$apiDockerVersion node /opt/api/codestream-server/$script_name "$@"
	docker run --rm -v $CS_ROOT:/opt/config --network=host $apiRepo:$apiDockerVersion node /opt/api/codestream-server/$script_name "$@"
}

# execute a api_server/bin/ script in an API container
function run_api_utility {
	local util_name=$1
	shift
	run_script_via_api api_server/bin/$util_name "$@"
}

function run_python_script {
	# this reports results to stdout so redirect other msgs to stderr
	[ "$CS_PRODUCT_TYPE" != "Single Linux Host" ] && echo "utility only available for Single Linux Host installations" && exit 1
	[ $CS_DEBUG_MODE -eq 1 ] && echo "docker run --rm  --network=host -v $CS_ROOT:/cs $pythonRepo:$dtPython3DockerVersion $*" >&2
	docker run --rm  --network=host -v $CS_ROOT:/cs $pythonRepo:$dtPython3DockerVersion $*
}

# execute a script residing on the host OS disk using an API container
function run_support_script_via_api {
	local script_name=$1
	[ -z "$script_name" ] && "script name required" && return 1
	[ "$CS_PRODUCT_TYPE" != "Single Linux Host" ] && echo "utility only available for Single Linux Host installations" && return 1
	script_name=`basename $script_name`
	[ ! -d $CS_ROOT/support ] && { mkdir $CS_ROOT/support || return 1; }
	[ ! -f $CS_ROOT/support/$script_name ] && { echo "$CS_ROOT/support/$script_name not found" && return 1; }
	docker run --rm -v $CS_ROOT:/opt/config --network=host $apiRepo:$apiDockerVersion node /opt/config/support/`basename $script_name`
}

function api_interactive {
	[ "$CS_PRODUCT_TYPE" != "Single Linux Host" ] && echo "utility only available for Single Linux Host installations" && exit 1
	echo docker run -it --rm -v $CS_ROOT:/opt/config --network=host $apiRepo:$apiDockerVersion /bin/bash "$@"
	docker run -it --rm -v $CS_ROOT:/opt/config --network=host $apiRepo:$apiDockerVersion /bin/bash "$@"
	exit $?
}

# 
# ###########################################################
# # Container Control
# ###########################################################

# determine a container's state and report it on stdout
function container_state {
	local container=$1
	docker inspect --format='{{.State.Status}}' $container  2>/dev/null|grep -v '^[[:blank:]]*$'
}

# report container and volume status
function docker_status {
	local authStatus="$1"
	# docker ps -a|egrep -e '[[:blank:]]cs|NAME'
	docker ps -a|egrep -e 'cs|NAME'
	echo
	docker volume ls | egrep -e 'csmongodata|VOL'
	if [ -n "$authStatus" -a -f $CS_ROOT/.status-urls ]; then
		. $CS_ROOT/.status-urls
		echo
		echo "api         : $apiUrl [`curl -s $apiUrl/no-auth/status`]"
		echo "admin       : $adminUrl [`curl -s $adminUrl/api/no-auth/status`]"
		echo "broadcaster : $bcastUrl [`curl -s $bcastUrl/no-auth/status`]"
	fi
}

function docker_network_args {
	local port
	case "$CS_PRODUCT_TYPE" in
		'Single Linux Host') echo "--network=host";;
		'Single Mac Host') for port in "$@"; do echo -n " -p $port:$port"; done; echo;;
		*) echo "unknown CS_PRODUCT_TYPE='$CS_PRODUCT_TYPE'" >&2; exit 1;;
	esac
}

# start up a container regardless if it already exists
# extra parms are sent to docker run command
function run_or_start_container {
	local port="" container="$1"
	shift
	[ -n "$1" ] && port="$1"  && shift
	[ $CS_DEBUG_MODE -eq 1 ] && echo "starting container $container on port $port"
	local state=$(container_state $container)
	[ "$state" == "running" ] && echo "Container $container is already running" >&2 && return
	if [ "$state" == "exited" ]; then
		echo "docker start $container"
		docker start $container
		return
	fi
	local containerEnv=""
	# [ $CS_USE_ADMIN -eq 1 -a -f $CS_ROOT/.container-run-params ] && containerEnv=`cat $CS_ROOT/.container-run-params`
	[ $CS_USE_ADMIN -eq 1 ] && containerEnv="$containerEnv --env CSSVC_CFG_URL=$CS_MONGO_URL --env CSSVC_CFG_FILE" && export CSSVC_CFG_FILE=""
	[ -n "$state" ] && echo "Container $container is in an unknown state ($state). Aborting" >&2 && return

	# IMPORTANT!!!!!!!!!!!!!!
	#
	# In docker under linux --network=host sets up host based networking which
	# will ignore the port publishing options (-p, -P) making the containers
	# available on their internally bound ports (typically the ones that are
	# exposed).
	#
	# In docker on a mac --network=host is ignored (not supported) and the
	# published ports are used, requiring us to know the ports we want to use.
	echo "running container $container (docker run)"
	case $container in
		csmongo)
			echo docker run -d $(docker_network_args 27017) -v csmongodata:/data/db --name csmongo mongo:$mongoDockerVersion
			docker run -d $(docker_network_args 27017) -v csmongodata:/data/db --name csmongo mongo:$mongoDockerVersion
			;;
		csrabbitmq)
			echo docker run -d $(docker_network_args 5672) --name csrabbitmq "$@" $rabbitmqRepo:$rabbitDockerVersion
			docker run -d $(docker_network_args 5672) --name csrabbitmq "$@" $rabbitmqRepo:$rabbitDockerVersion
			;;
		csapi)
			echo docker run -d $(docker_network_args $port) -v $CS_ROOT:/opt/config --name csapi --env CSSVC_PRODUCT_TYPE=\"$CS_PRODUCT_TYPE\" $containerEnv "$@" $apiRepo:$apiDockerVersion
			docker run -d $(docker_network_args $port) -v $CS_ROOT:/opt/config --name csapi --env CSSVC_PRODUCT_TYPE="$CS_PRODUCT_TYPE" $containerEnv "$@" $apiRepo:$apiDockerVersion
			;;
		csbcast)
			echo docker run -d $(docker_network_args $port) -v $CS_ROOT:/opt/config --name csbcast --env CSSVC_PRODUCT_TYPE=\"$CS_PRODUCT_TYPE\" $containerEnv "$@" $broadcasterRepo:$broadcasterDockerVersion
			docker run -d $(docker_network_args $port) -v $CS_ROOT:/opt/config --name csbcast --env CSSVC_PRODUCT_TYPE="$CS_PRODUCT_TYPE" $containerEnv "$@" $broadcasterRepo:$broadcasterDockerVersion
			;;
		csmailout)
			echo docker run -d $(docker_network_args $port) -v $CS_ROOT:/opt/config --name csmailout --env CSSVC_PRODUCT_TYPE=\"$CS_PRODUCT_TYPE\" $containerEnv "$@" $mailoutRepo:$mailoutDockerVersion
			docker run -d $(docker_network_args $port) -v $CS_ROOT:/opt/config --name csmailout --env CSSVC_PRODUCT_TYPE="$CS_PRODUCT_TYPE" $containerEnv "$@" $mailoutRepo:$mailoutDockerVersion
			;;
		csadmin)
			echo docker run -d $(docker_network_args $port) -v $CS_ROOT:/opt/config --name csadmin --env CSSVC_PRODUCT_TYPE=\"$CS_PRODUCT_TYPE\" $containerEnv "$@" $opadmRepo:$opadmDockerVersion
			docker run -d $(docker_network_args $port) -v $CS_ROOT:/opt/config --name csadmin --env CSSVC_PRODUCT_TYPE="$CS_PRODUCT_TYPE" $containerEnv "$@" $opadmRepo:$opadmDockerVersion
			;;
		*)
			echo "don't know how to start container $container" >&2
			return;;
	esac
	return
}

# high-level routine to startup all containers
# flags:
#    not-mongo:  don't start mongo
function start_containers {
	local flags="$1"
	[ -n "$1" ] && shift
	[ $CS_DEBUG_MODE -eq 1 ] && echo "start_containers(flags=$flags, args=$*)"

	[ $CS_RUN_MONGO -eq 1 ] && echo ",$flags," | grep -qv not-mongo && { run_or_start_container csmongo; sleep 5; }

	# we are sorely in need of a real programming language here...
	echo ",$flags," | grep -q port-file
	if [ $? -eq 0 ]; then
		[ ! -f $CS_ROOT/.container-ports ] && echo "$CS_ROOT/.container-ports not found" && exit 1
		eval `cat $CS_ROOT/.container-ports`
	else
		echo "Fetching ports from the database..."
		eval "`mongo_config_tool --dump active --container-ports`"
	fi

	[ $CS_DEBUG_MODE -eq 1 ] && echo -e "apiServerPort=$apiServerPort\nbroadcasterPort=$broadcasterPort\nadminServerPort=$adminServerPort"

	echo "Starting containers..."
	run_or_start_container csrabbitmq
	sleep 3
	run_or_start_container csapi $apiServerPort "$@"
	sleep 3
	run_or_start_container csbcast $broadcasterPort
	run_or_start_container csmailout
	[ $CS_USE_ADMIN -eq 1 ] && run_or_start_container csadmin $adminServerPort
	return 0
}

# high-level routine to stop all containers
function stop_containers {
	local flags="$1"
	shift
	local containers="$CS_CONTAINERS"
	[ -n "$1" ] && flags="not-mongo" && containers="$@"
	local c
	local state
	[ $CS_RUN_MONGO -eq 1  -a  "$flags" != "not-mongo" ] && containers="$containers csmongo"
	echo "Stopping containers..."
	for c in $containers
	do
		state=$(container_state $c)
		# echo "container $c state: $state"
		if [ "$state" == "running" ]; then
			docker stop $c
		elif [ "$state" == "exited" ]; then
			echo "container $c is not running "
		elif [ -z "$state" ]; then
			echo "container $c not found - nothing to stop"
		else
			echo "container $c is in an unknown state ($state)"
		fi
	done
}

# high-level routine to stop all containers
function remove_containers {
	local flags="$1"
	shift
	local containers="$CS_CONTAINERS"
	[ -n "$1" ] && flags="not-mongo" && containers="$@"
	local c
	local state
	[ $CS_RUN_MONGO -eq 1  -a  "$flags" != "not-mongo" ] && containers="$containers csmongo"
	echo "Removing containers..."
	for c in $containers
	do
		state=$(container_state $c)
		if [ "$state" == "exited" ]; then
			docker rm $c
		elif [ -z "$state" ]; then
			echo "container $c not found - nothing to remove"
		else
			echo "container $c is in an unexpected state ($state)"
		fi
	done
	# [ $CS_RUN_MONGO -eq 1 ] && echo "docker rm csmongo" && docker rm csmongo
}

# 
# start_compose()
#   desc: bring up or start the docker compose environment
#   returns:
#         none
function start_compose {
	[ $CS_DEBUG_MODE -eq 1 ] && echo docker-compose -p codestream -f $CS_ROOT/compose.yaml up --detach
	docker-compose -p codestream -f $CS_ROOT/compose.yaml up --detach
}

# 
# stop_compose()
#   desc: stop compose services
#   returns:
#         none
function stop_compose {
	[ $CS_DEBUG_MODE -eq 1 ] && echo docker-compose -p codestream -f $CS_ROOT/compose.yaml stop
	docker-compose -p codestream -f $CS_ROOT/compose.yaml stop
}

# 
# restart_compose()
#   desc: restart compose services
#   returns:
#         none
function restart_compose {
	[ $CS_DEBUG_MODE -eq 1 ] && echo docker-compose -p codestream -f $CS_ROOT/compose.yaml restart
	docker-compose -p codestream -f $CS_ROOT/compose.yaml restart
}

# 
# down_compose()
#   desc: bring down the docker compose environment
#   returns:
#         none
function down_compose {
	[ $CS_DEBUG_MODE -eq 1 ] && echo docker-compose -p codestream -f $CS_ROOT/compose.yaml down
	docker-compose -p codestream -f $CS_ROOT/compose.yaml down
}


# 
# start_services()
#  desc: start services (single host or compose)
#  returns:
#        none
function start_services {
	case "$CS_PRODUCT_TYPE" in
		"Docker Compose") start_compose "$@";;
		*) start_containers "$@";;
	esac
}

# 
# stop_services()
#  desc: stop services (single host or compose)
#  returns:
#        none
function stop_services {
	case "$CS_PRODUCT_TYPE" in
		"Docker Compose") stop_compose "$@";;
		*) stop_containers "$@";;
	esac
}

# 
# restart_services()
#  desc: restart services (single host or compose)
#  returns:
#        none
function restart_services {
	case "$CS_PRODUCT_TYPE" in
		"Docker Compose") restart_compose "$@";;
		*) stop_containers "$@"; sleep 1; start_containers "$@";;
	esac
}

# 
# reset_services()
#  desc: reset services (single host or compose)
#  returns:
#        none
function reset_services {
	case "$CS_PRODUCT_TYPE" in
		"Docker Compose") down_compose "$@";;
		*) stop_containers "$@"; sleep 1; remove_containers "$@";;
	esac
}


# 
# load_docker_containers_from_packages()
#   desc: load docker images from disk for air-gapped installations
#   returns:
#         none
function load_docker_containers_from_package {
	echo "loading docker images from package"
	set -x
	docker load -i $CS_ROOT/.docker-images/api.$apiDockerVersion.docker || exit 1
	docker load -i $CS_ROOT/.docker-images/broadcaster.$broadcasterDockerVersion.docker || exit 1
	docker load -i $CS_ROOT/.docker-images/mailout.$mailoutDockerVersion.docker || exit 1
	[ $CS_USE_ADMIN -eq 1 ] && { docker load -i $CS_ROOT/.docker-images/opadm.$opadmDockerVersion.docker || exit 1; }
	docker load -i $CS_ROOT/.docker-images/rabbitmq.$rabbitDockerVersion.docker || exit 1
	docker load -i $CS_ROOT/.docker-images/python.$dtPython3DockerVersion.docker || exit 1
	docker load -i $CS_ROOT/.docker-images/mongo.$mongoDockerVersion.docker || exit 1
	set +x
}


# 
# ###########################################################
# # Installation
# ###########################################################

# display our terms of service and require user to agree.
# returns 0 if they do agree, 1 otherwise
function accept_tos {
	[ -f $CS_ROOT/.tos-agreed ] && return 0
	local ans
	echo -n "
Before proceeding with the installation, you will need to accept our
Terms of Service. Use the space-bar, 'b' (for back) or arrow keys to
move through the pager to read the terms. Press 'q' when you're done.

You'll then need agree to the terms to continue with the installation.

Press ENTER to read our Terms of Service..."
	read ans
	if [ ! -f $CS_ROOT/terms.txt ]; then
		curl https://raw.githubusercontent.com/TeamCodeStream/onprem-install/$CS_INSTALLATION_BRANCH/docs/src/assets/terms.txt -s -o $CS_ROOT/terms.txt
		[ $? -ne 0 ] && echo "Could not locate the terms of service!" && exit 1
	fi
	less $CS_ROOT/terms.txt
	echo -n "

If you agree to these terms, please type 'i agree': "
	read ans
	ans=`echo $ans | $TR_CMD [:upper:] [:lower:]`
	[ "$ans" == "i agree" ] && touch $CS_ROOT/.tos-agreed && return 0
	return 1
}

function quickstart {
	[ -f $CS_ROOT/mongo.url ] && echo "CodeStream was already installed" && exit 1
	local _apiPublicPort=80
	local _bcastPort=12080
	local _adminPort=8080
	# local _fqhn=`hostname` # hostname is the default topology
	local _fqhn=$(guess_primary_ip) # ip address is the default topology
	local _mongoUrl=$CS_MONGO_URL
	local interactive=1
	local _x
	local apiEnv=""
	# FIXME: would be better if we did not hard code /opt/api/
	if [ "$CS_PRODUCT_TYPE" == "Single Linux Host" ]; then
		export CS_API_DEFAULT_CFG_FILE=/opt/api/codestream-server/api_server/etc/configs/onprem-slh-quickstart.json
	elif [ "$CS_PRODUCT_TYPE" == "Single Mac Host" ]; then
		export CS_API_DEFAULT_CFG_FILE=/opt/api/codestream-server/api_server/etc/configs/onprem-smh-quickstart.json
	else
		echo "Unknown product type ($CS_PRODUCT_TYPE)"
		exit 1
	fi
	while [ $# -gt 0 ]
	do
		case $1 in
			--compose)
				export CS_PRODUCT_TYPE="Docker Compose"
				_mongoUrl="mongodb://csmongo/codestream"
				shift;;
			--topology)
				[ "$2" == hostname ] && _fqhn=`hostname`
				# [ "$2" == ip ] && _fqhn=$(guess_primary_ip)
				[ -z "$2"  -o  \( "$2" != "ip"  -a  "$2" != "hostname" \) ] && echo "bad usage. Specify a 'hostname' or 'ip' topology." && exit 1
				shift 2;;
			--public-host)
				[ "$2" != ip ] && _fqhn=$2
				shift 2;;
			--api-port) _apiPublicPort=$2; apiEnv="$apiEnv --env CS_API_SET_PUBLIC_PORT=$2"; shift 2;;
			--admin-port) _adminPort=$2; apiEnv="$apiEnv --env CS_API_SET_PUBLIC_ADMIN_PORT=$2"; shift 2;;
			--bcast-port) _bcastPort=$2; apiEnv="$apiEnv --env CS_API_SET_PUBLIC_BROADCASTER_PORT=$2"; shift 2;;
			--mongo-url) _mongoUrl=$2; shift 2;;
			--agree-to-terms) interactive=0; shift;;
			*) echo "bad usage"; exit 1;;
		esac
	done
	[ -z "$_fqhn" ] && echo "could not determine a default hostname. Use '--public-host' option" && exit 1
	export CS_API_SET_PUBLIC_HOST=$_fqhn
	[ $interactive -eq 0 ] && touch $CS_ROOT/.tos-agreed || { accept_tos || exit 1; }
	# fetch_utilities

	echo "Product Type: $CS_PRODUCT_TYPE"
	echo "Configuring CodeStream with these public-facing settings:
    Host             [--public-host] :    $_fqhn
    API Port         [--api-port]    :    $_apiPublicPort
    Broadcaster Port [--bcast-port]  :    $_bcastPort
    Admin Port       [--admin-port]  :    $_adminPort"
	# Mongo URL:         $_mongoUrl    (--mongo-url)
	echo -n "
If this is not what you want, press CTRL-C and specify additional options along with --quickstart
"
	[ $interactive -eq 1 ] && { echo -n "Press ENTER to continue..." && read _x; } || echo "interactive mode disabled...continuing..."

	echo $CS_PRODUCT_TYPE >$CS_ROOT/product-type

	cat >$CS_ROOT/.status-urls <<EOF
apiUrl="http://$_fqhn:$_apiPublicPort"
bcastUrl="http://$_fqhn:$_bcastPort"
adminUrl="http://$_fqhn:$_adminPort"
EOF
	echo $_mongoUrl >$CS_ROOT/mongo.url
	export CS_MONGO_URL=$_mongoUrl
	export CS_USE_ADMIN=1

	echo -e "apiServerPort=$_apiPublicPort\nbroadcasterPort=$_bcastPort\nadminServerPort=$_adminPort" >$CS_ROOT/.container-ports

	# air-gapped installations get the docker images pre-loaded from disk
	load_container_versions
	[ -n "$CS_INSTALL_FROM_PKG" ] && load_docker_containers_from_package

	if [ "$CS_PRODUCT_TYPE" == "Docker Compose" ]; then
		update_compose_file port-file
		start_compose
	else
		start_containers --with-mongo,port-file $apiEnv --env CS_API_SET_PUBLIC_HOST=$CS_API_SET_PUBLIC_HOST --env CS_API_DEFAULT_CFG_FILE=$CS_API_DEFAULT_CFG_FILE
	fi
	/bin/rm -f $CS_ROOT/.container-ports
	exit
}

# 
# ###########################################################
# # Logs & Support
# ###########################################################

function tail_logs {
	local numLines="$1"
	[ -z "$numLines" ] && numLines=10
	local containers="csapi csbcast csmailout"
	[ $CS_USE_ADMIN -eq 1 ] && containers="$containers csadmin"
	local service
	for service in $containers
	do
		echo "=========== $service ==========="; docker logs --tail $numLines $service; echo
	done
}

function capture_logs {
	local since=$1
	[ -z "$since" ] && echo "bad usage: missing hours or minutes spec" && exit 1
	[ ! -d $CS_ROOT/log-capture ] && mkdir $CS_ROOT/log-capture
	local logdir=cslogs$$
	local now=`date +%Y%m%d-%H%M%S`
	tmpDir=$HOME/$logdir
	mkdir $tmpDir
	docker logs --since $since csapi >$tmpDir/api.log 2>&1
	docker logs --since $since csbcast >$tmpDir/broadcaster.log 2>&1
	docker logs --since $since csrabbitmq >$tmpDir/rabbitmq.log 2>&1
	docker logs --since $since csmailout >$tmpDir/mailout.log 2>&1
	[ $CS_USE_ADMIN -eq 1 ] && docker logs --since $since csadmin >$tmpDir/opadm.log 2>&1
	tar -czpf $CS_ROOT/log-capture/codestream-onprem-logs.$now.tgz -C $HOME $logdir
	[ -d "$tmpDir" ] && /bin/rm -rf $tmpDir
	ls -l $CS_ROOT/log-capture/codestream-onprem-logs.$now.tgz
}

# use a mongo container to run a json script using the mongo CLI
function repair_db {
	# this will execute scripts containing mongodb commands
	local fixScript=$1
	[ -z "$fixScript" ] && echo "name of fix script is required" && return 1
	fixScript=$(basename $fixScript)
	[ ! -f $CS_ROOT/$fixScript ] && echo "$CS_ROOT/$fixScript not found" >&2 && return 1
	docker run --rm $(docker_network_args 27017) -v $CS_ROOT:/cs mongo:$mongoDockerVersion mongo $CS_MONGO_URL /cs/$fixScript && echo "repair script ran successfully" || { echo "repair script indicated failure"; return 1; }
	return 0
}

# create a custom MS Teams App Package for side-loading into MST
function create_mst_app_pkg {
	local appId=$1
	local publicHostName=$2
	zipCmd=`which zip`
	[ -z "$zipCmd" ] && echo "'zip' is needed to create an MST app package. It was not found in your search path" && return 1
	[ -z "$publicHostName" ] && echo "usage: `basename $0` --create-mst-app-pkg {appId} {public-api-hostname}" && return 1
	local tmpDir="$CS_ROOT/tmp$$"
	mkdir $tmpDir || { echo "mkdir $tmpDir failed"; return 1; }
	curl -s https://assets.codestream.com/mstbot/template/manifest.json.onprem -o $tmpDir/manifest.json.onprem || { echo "failed to get manifest template"; return 1; }
	curl -s https://assets.codestream.com/mstbot/template/outline.png -o $tmpDir/outline.png || { echo "failed to get outline.png"; return 1; }
	curl -s https://assets.codestream.com/mstbot/template/color.png -o $tmpDir/color.png || { echo "failed to get color.png"; return 1; }
	cat $tmpDir/manifest.json.onprem | sed -e "s/{{botId}}/$appId/g" | sed -e "s/{{publicApiFullyQualifiedHostName}}/$publicHostName/g" > $tmpDir/manifest.json || { echo "could not expand manifest template"; return 1; }
	(cd $tmpDir && $zipCmd -q $CS_ROOT/codestream-mst-app.zip manifest.json outline.png color.png) || { echo "failed to create zip file"; return 1; }
	ls -l $CS_ROOT/codestream-mst-app.zip
	/bin/rm -rf $tmpDir
	return 0
}

# openssl command to generate a self-signed cert
function make_self_signed_cert {
	local fqhn="$1"
	[ -z "$fqhn" ] && echo "specify the hostname for your cert" && exit 1
	local opensslCmd=`which openssl`
	[ -z "$opensslCmd" ] && echo "openssl command not found - this is needed to create a self-signed cert" && exit 1
	cd $CS_ROOT || exit 1
	echo "Creating key (./$fqhn.key.pem) and self-signed cert (./$fqhn.cert.pem)"
	echo openssl req -nodes -x509 -newkey rsa:4096 -keyout $fqhn.key.pem -out $fqhn.cert.pem -days 3650 -subj \"/C=US/ST=NY/L=New York/O=Dis/CN=$fqhn\"
	openssl req -nodes -x509 -newkey rsa:4096 -keyout $fqhn.key.pem -out $fqhn.cert.pem -days 3650 -subj "/C=US/ST=NY/L=New York/O=Dis/CN=$fqhn" || return 1
	return 0
}

# optionally fetch and execute a CodeStream supplied support package.
#
# Support packages are tarballs containing custom scripts CodeStream support
# prepares for specific problems with client installations.
function apply_support_package {
	local supportPkg=$1
	shift
	local curDir=`pwd`
	[ -z "$supportPkg" ] && echo "support pacakge filename is required" && return 1
	supportPkgFile=`basename $supportPkg`

	[ ! -d $CS_ROOT/support ] && { mkdir $CS_ROOT/support || return 1; }
	local supportId=`date +%Y%m%d.%H%M%S.%s`
	local supportDir="$CS_ROOT/support/$supportId"
	echo "mkdir $supportDir" && mkdir $supportDir || return 1

	if [ "`echo $supportPkg | grep -c ^https:`" -gt 0 ]; then
		echo "curl $supportPkg -o $supportDir/$supportPkgFile -s"
		curl $supportPkg -o $supportDir/$supportPkgFile -s || { echo "could not download support package" && return 1; }
	else
		[ ! -f "$supportPkg" ] && echo "$supportPkg not found" && return 1
		/bin/cp $supportPkg $supportDir || return 1
	fi

	cd $supportDir || return 1
	tar -xzf $supportPkgFile || { echo "untar $supportPkgFile failed" && return 1; }

	[ ! -f start-here.sh ] && echo "missing start script" && return 1
	echo running package - /bin/bash ./start-here.sh "$CS_ROOT" "$@"
	/bin/bash ./start-here.sh "$CS_ROOT" "$@"
	return $?
}

function mongo_config_tool {
	local outFile="$1"
	[ ! -f $CS_ROOT/mongo.url ] && echo "installation upgrade required" && exit 1
	run_script_via_api shared/codestream_configs/bin/mongo-config-loader.js --mongo-url $CS_MONGO_URL "$@"
	exit $?
}

# 
# ###########################################################
# # Upgrade to On-Prem Admin Server
# ###########################################################

function upgrade_to_admin {
	[ $CS_USE_ADMIN -eq 1 ] && echo "Your installatton is already running the admin service" && exit 0
	local _mongoUrl=`grep mongodb:// $CS_ROOT/codestream-services-config.json |cut -f4 -d\" | head -1`
	local apiEnv=""
	local _publicUrlWithoutPort=`grep publicApiUrl $CS_ROOT/codestream-services-config.json | cut -f4 -d\" | cut -f1-2 -d:`
	local _apiPublicPort=`grep publicApiUrl $CS_ROOT/codestream-services-config.json | cut -f4 -d\" | cut -f3 -d:`
	local _adminPort=8080
	echo $_publicUrlWithoutPort|grep -q ^https && _adminPort=8443
	[ "$_adminPort" == "$_apiPublicPort" ] && $_adminPort=`expr $_adminPort + 1`
	while [ $# -gt 0 ];	do
		case $1 in
			--admin-port) _adminPort=$2; shift 2;;
			--mongo-url) _mongoUrl=$2; shift 2;;
			*) echo "bad usage"; exit 1;;
		esac
	done
	local _adminUrl="$_publicUrlWithoutPort:$_adminPort"
	echo "You are about to upgrade your CodeStream On-Prem installation to use
the new admin service which migrates your configuration into the mongo
database.

Once completed, your codestream-services-config.json file will be moved
aside and no longer relevant. Any configuration changes should be made
through the web browser app which will run on the admin port you specify.

   Admin Port       [--admin-port]  :    $_adminPort
   Mongo Url        [--mongo-url]   :    $_mongoUrl
   Admin Url                        :    $_adminUrl

If these settings are not to your liking, break out of this script (CTRL-C)
and use the command line options to change their values
"
	yesno "Do you want to proceed with these options (y/N)? " && echo "Upgrade aborted" && exit 1

	stop_containers not-mongo
	full_backup
	remove_containers not-mongo

	echo $CS_PRODUCT_TYPE >$CS_ROOT/product-type

	echo $_mongoUrl >$CS_ROOT/mongo.url
	export CS_MONGO_URL=$_mongoUrl
	export CS_USE_ADMIN=1
	#  load config into mongo, setting the public-facing admin port and import SSL/TLS certs/keys
	run_script_via_api shared/codestream_configs/bin/mongo-config-loader.js --mongo-url $CS_MONGO_URL --load /opt/config/codestream-services-config.json --desc "import codestream-config-services.json" --first-cfg-hook --admin-port $_adminPort || { echo "failed to load config"; exit 1; }
	mv $CS_ROOT/codestream-services-config.json $CS_ROOT/codestream-services-config.json.loaded-into-db

	start_containers not-mongo

	echo "Done.

Login to the admin server at $_adminUrl and setup an email address & password.

You can always see the logs with these commands:

    docker logs csapi
    docker logs csbcast
    docker logs csadmin
"
	exit 0
}


#########
#########  Execution Starts Here
#########


### ------ Globals ------

export CS_CONTAINERS="csapi csmailout csbcast csrabbitmq"

[ -z "$CS_ROOT" ] && csDir=`dirname $0` && export CS_ROOT=$(cd $csDir && pwd)

## commands that aren't the same on different os's
[ -z "$TR_CMD" ] && export TR_CMD=tr

## .onprem-install is a copy of a the onprem-install repo used for air-gapped installations
[ -d $CS_ROOT/.onprem-install ] && export CS_INSTALL_FROM_PKG=yes || export CS_INSTALL_FROM_PKG=""

## touch debug.on if you want debugging output
[ -f $CS_ROOT/debug.on ] && export CS_DEBUG_MODE=1 || export CS_DEBUG_MODE=0

## The release file determines which docker repos and image versions we use (beta, pre-release or GA (null string))
[ -f $CS_ROOT/release ] && { export CS_RELEASE=`cat $CS_ROOT/release`; export CS_RELEASE_SUFX=".$CS_RELEASE"; export CS_RELEASE_PATH="/$CS_RELEASE"; echo "Release: $CS_RELEASE" >&2; }
[ "$CS_RELEASE" == development -a -z "$OPI_SANDBOX" ] && echo "you're setup for development but the onprem-install sandbox is not loaded" && exit 1

## installation-branch determines which branch of onprem-install to use when downloading files (master or beta)
[ -f $CS_ROOT/installation-branch ] && { export CS_INSTALLATION_BRANCH="`cat $CS_ROOT/installation-branch`"; echo "Installation branch: $CS_INSTALLATION_BRANCH" >&2; } || export CS_INSTALLATION_BRANCH="master"

## product type
[ -f $CS_ROOT/product-type ] && export CS_PRODUCT_TYPE=`cat $CS_ROOT/product-type` || export CS_PRODUCT_TYPE="Single $(system_type) Host"

## mongo server
## [ -z "$CS_MONGO_URL" ] && { [ -f $CS_ROOT/mongo.url ] && export CS_MONGO_URL=`cat $CS_ROOT/mongo.url` || export CS_MONGO_URL="mongodb://localhost/codestream"; }
if [ -z "$CS_MONGO_URL" ]; then
	if [ -f $CS_ROOT/mongo.url ]; then
		export CS_MONGO_URL=`cat $CS_ROOT/mongo.url`
	else
		if [ "$CS_PRODUCT_TYPE" == "Single Mac Host" ]; then
			export CS_MONGO_URL="mongodb://host.docker.internal/codestream"
		elif [ "$CS_PRODUCT_TYPE" == "Single Linux Host" ]; then
			export CS_MONGO_URL="mongodb://localhost/codestream"
		else
			echo "Unknown product type"
			exit 1
		fi
	fi
fi

## Admin server
[ -f $CS_ROOT/mongo.url ] && export CS_USE_ADMIN=1 || export CS_USE_ADMIN=0
[ $CS_USE_ADMIN -eq 1 ] && export CS_CONTAINERS="$CS_CONTAINERS csadmin"

## touch mongo.off if user provided mongodb server (no mongo docker container)
[ -f $CS_ROOT/mongo.off ] && export CS_RUN_MONGO=0 || export CS_RUN_MONGO=1

## [ -n "$OPI_TOP" -a -d "$OPI_TOP/install-scripts" ] && export CS_OPI_SANDBOX=1 || export CS_OPI_SANDBOX=0

### ------ Checkout this host system for compatibility
check_env || exit 1

[ $CS_DEBUG_MODE -eq 1 ] && env | grep ^CS_

### ------ Start parsing command line options
[ "$1" == "--help" -o -z "$1" ] && usage
[ "$1" == "--quickstart" ] && { shift && quickstart "$@"; exit $?; }
[ "$1" == "--update-myself" ] && update_myself
[ ! -f $CS_ROOT/container-versions ] && echo "CodeStream On-Prem not installed" && exit 1
[ "$1" == "--undo-stack" ] && { print_undo_stack; exit $?; }
[ "$1" == "--apply-support-pkg" ] && shift && { apply_support_package "$@"; exit $?; }
[ "$1" == "--create-mst-app-pkg" ] && shift && { create_mst_app_pkg "$@"; exit $?; }
[ "$1" == "--make-self-signed-cert" ] && shift && { make_self_signed_cert "$@"; exit $?; }

load_container_versions

[ "$1" == "--api-shell" ] && shift && { api_interactive "$@"; exit $?; }
[ "$1" == "--upgrade-to-admin" ] && shift && { upgrade_to_admin "$@"; exit $?; }
[ "$1" == "--run-python-script" ] && shift && { run_python_script "$@"; exit $?; }
[ "$1" == "--run-support-script" ] && { run_support_script_via_api "$2"; exit $?; }
[ "$1" == "--run-api-utility" ] && shift && { run_api_utility "$@"; exit $?; }
[ "$1" == "--repair-db" ] && { repair_db "$2"; exit $?; }
[ "$1" == "--update-containers" ] && shift && { update_containers_except_mongo --force "$@"; exit $?; }
[ "$1" == "--logs" ] && { capture_logs "$2"; exit $?; }
[ "$1" == "--logtail" ] && shift && { tail_logs "$@"; exit $?; }
[ "$1" == "--backup" ] && { backup_mongo $CS_MONGO_URL; exit $?; }
[ "$1" == "--full-backup" ] && { full_backup; exit $?; }
[ "$1" == "--restore" ] && { [ "$2" == latest ] && { { restore_mongo $CS_MONGO_URL "$(/bin/ls $CS_ROOT/backups/dump_*.gz | tail -1)"; exit $?; } || { restore_mongo $CS_MONGO_URL $2; exit $?; } } }
[ "$1" == "--cfg-tool" ] && shift && { mongo_config_tool "$@"; exit $?; }

[ "$1" == "-a" ] && echo -e "\nThe -a option is no longer avaiable.\n" && usage
[ "$1" == "--status" ] && shift && { docker_status auth; exit; }
[ "$1" == "--start" ] && shift && { start_services "$@"; sleep 1; docker_status; exit; }
[ "$1" == "--stop" ] && shift && { stop_services "$@"; exit; }
[ "$1" == "--restart" ] && shift && { restart_services "$@"; sleep 1; docker_status; exit; }
[ "$1" == "--reset" ] && shift && { reset_services "$@"; exit; }
[ "$1" == "--start-mongo" ] && shift && { run_or_start_container csmongo; sleep 2; docker_status; exit; }

## undocumented - know what you're doing!!
[ "$1" == "--run" ] && shift && { [ -n "$1" ] && run_or_start_container "$@" || echo "container name required"; exit $?; }
[ "$1" == "--reset-some" ] && shift && { [ -n "$1" ] && { stop_containers "" "$@"; remove_containers "" "$@"; } || echo "container name(s) required"; exit $?; }
[ "$1" == "--replace" ] && shift && { $0 --reset-some "$@"; $0 --run "$@"; exit $?; }
[ "$1" == "--update-container-versions" ] && shift && { update_container_versions; exit $?; }
[ "$1" == "--reset-dev-env" ] && { reset_dev_env; exit $?; }

usage
